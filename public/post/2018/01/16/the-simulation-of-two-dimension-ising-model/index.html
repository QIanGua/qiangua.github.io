<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>The simulation of two dimension Ising model - 采采流水</title>
    <meta property="og:title" content="The simulation of two dimension Ising model - 采采流水">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="[TOC]
[&amp;hellip;] **Update: 2018/1/16 ** Begin:2017/10/5
[&amp;hellip;] 伊辛模型是用来研究固体磁性最为重要的模型之一，而昂萨格(Onsager)于1944年对二维伊辛模型的解析解的发现则标志着统计物理的新篇章。
一个由$N$个固定点构成的$S$维规则磁性点阵，每个点上放置一个自旋向上或向下的粒子。整个系统的状态由序 &amp;hellip;">
      <meta property="og:description" content="[TOC]
[&amp;hellip;] **Update: 2018/1/16 ** Begin:2017/10/5
[&amp;hellip;] 伊辛模型是用来研究固体磁性最为重要的模型之一，而昂萨格(Onsager)于1944年对二维伊辛模型的解析解的发现则标志着统计物理的新篇章。
一个由$N$个固定点构成的$S$维规则磁性点阵，每个点上放置一个自旋向上或向下的粒子。整个系统的状态由序 &amp;hellip;">
      
    

    
    
    <meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/26717-40c92a2ca8f6d4eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    
    

    

    
    


<link href='//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  
  <body class="post">
    <header class="masthead">
      <h1><a href="/">采采流水</a></h1>

<p class="tagline"> An Essay Concerning Human Understanding</p>

      <nav class="menu">
  <input id="menu-check" type="checkbox" />
  <label id="menu-label" for="menu-check" class="unselectable">
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li><a href="/">Home</a></li>
  
  <li><a href="/about/">About</a></li>
  
  <li><a href="/books/">Books</a></li>
  
  <li><a href="/fragments/">Fragments</a></li>
  
  <li><a href="/index.xml">Subscribe</a></li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>The simulation of two dimension Ising model</h1>

<h3>
  2018-01-16</h3>
<hr>


      </header>





<h1 id="the-simulation-of-2d-ising-model">The simulation of 2D Ising model</h1>

<p>[TOC]</p>

<blockquote>
<h3 id="ising-model-on-a-square-lattice">Ising model on a square lattice</h3>

<p>**Update: 2018/1/16 **
<strong>Begin:2017/10/5</strong></p>
</blockquote>

<h2 id="1-模型简述">1.模型简述</h2>

<p>伊辛模型是用来研究固体磁性最为重要的模型之一，而昂萨格(Onsager)于1944年对二维伊辛模型的解析解的发现则标志着统计物理的新篇章。</p>

<p>一个由$N$个固定点构成的$S$维规则磁性点阵，每个点上放置一个自旋向上或向下的粒子。整个系统的状态由序列$\mathcal{\sigma}=\left(\sigma_1,\sigma_2,\dots,\sigma_N\right)$来表征，每个自旋方向为向上或者向下：
$$
\sigma_i ={1,-1}
$$</p>

<p>下图是用 <strong>Mathematica</strong>  作出的一个图示：</p>

<p><center><img src="http://upload-images.jianshu.io/upload_images/26717-40c92a2ca8f6d4eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2D Ising Model" title="二维伊辛模型示意图" /></center></p>

<p>系统的哈密顿量(可理解为能量)：
$$
H<em>N\left( \mathcal{\sigma} \right) = -\sum</em>{\langle i,j\rangle}J_{ij}\sigma_i\sigma<em>j - \sum</em>{i=1}^N h_i \sigma<em>i
$$
其中，$J</em>{ij}$为耦合常数， 表示$\sigma_i$ 和$\sigma_j$ 之间的耦合强度，$h_i$ 是外磁场强度。</p>

<p>为了简化模拟过程，一般选取$J_{i,j}=J, h_i=0$。</p>

<p>在正则系综情况下，系统处于某一构型的概率服从玻尔兹曼分布：
$$
P<em>\sigma^{B}=\frac{\exp(-H(\sigma)\beta)}{\mathcal{Z}}
$$
其中 $\mathcal{z}$ 是配分函数，
$$
\mathcal{z}=\sum</em>{\sigma} e^{-\beta H(\sigma)}
$$
<strong>常用的物理量平均值是</strong>：</p>

<p>能量 $E$：
$$
E=\langle H \rangle = \sum<em>\sigma H(\sigma)P</em>\sigma^B
$$
平均磁化强度 $M$:
$$
\langle M \rangle=\frac{1}{N} \sum_i \sigma_i
$$</p>

<p>平均磁化率 $\chi$:
$$
\chi=\frac{\partial \langle M \rangle}{\partial H}=\frac{N}{k_b T}[\langle M^2\rangle-\langle M \rangle^2]
$$
比热$C_v$：
$$
C_v=\frac{d E}{d T}
$$</p>

<h2 id="2-算法流程">2.算法流程</h2>

<ol>
<li>构型初始化</li>
<li>设置温度区间</li>
<li>先让当前构型演化到平衡态，然后才能开始统计</li>
<li>随机选取一个自旋翻转(或者直接对所有格点遍历)</li>
<li>计算翻转前后两种构型的能量差$\Delta E$</li>
<li>若$\Delta E&lt;0$, 返回3；否则计算出翻转概率，并与0和1之间的随机数做比较</li>
<li>重复过程3-6，直至循环结束</li>
<li>画图能量、比热、磁化率、磁化强度</li>
</ol>

<h2 id="3-编程实现">3.编程实现</h2>

<p><strong>尝试使用简单热门的Python语言</strong></p>

<p><strong>参数设定：</strong></p>

<table>
<thead>
<tr>
<th align="center">$J$</th>
<th align="center">1</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">$k_b$</td>
<td align="center">1</td>
</tr>

<tr>
<td align="center">$T$</td>
<td align="center">0-6</td>
</tr>

<tr>
<td align="center">$h_i$</td>
<td align="center">0</td>
</tr>
</tbody>
</table>

<p>这里为了方便取$k_b=1, J=1$. 目前已知的临界温度的解析结果是
$$
T_c=2/\ln(1+\sqrt{2})\approx 2.269
$$</p>

<h2 id="4-结果图示">4.结果图示</h2>

<p>下图是$16\times 16$ 格子模拟的结果，结果比较理想：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/26717-e6304d07fd77f65c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ising15.jpg" /></p>

<p>下图是$2\times 2$ 格子模拟的结果：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/26717-b182b26f2af24045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ising2.png" /></p>

<p>从磁化强度和磁化率来看，$2\times 2$ 体系的模拟效果不是很理想。</p>

<h2 id="5-总结提高">5.总结提高</h2>

<p>模拟过程中要注意的一点是初始构型选定后，必须先让系统演化到平衡态，然后再开始进行 <strong>Metropolis</strong> 抽样， 因为在平衡态统计的框架下，系统只有到达平衡态之后各个物理量才能有确定的意义。</p>

<p>在验证程序正确性的时候，先选择尺寸为 $2\times 2$ 的格点，从平均磁化率和磁化强度和温度的关系来看临界温度，发现与解析结果差别较大，而从热容来看是与理论的临界温度$T_c$ 相吻合的。初步排除过非平衡因素之后，剩下的可能原因是体系的尺寸效应有关。 一方面实际在验证过程中，逐渐加大体系尺寸，可以观察到逐渐接近理论临界温度，另一方面还可能需要考察一下热容 和 磁化率、磁化强度计算准确度对尺寸的依赖情况。</p>

<h2 id="代码附录">代码附录</h2>

<pre><code class="language-python">#  PROGRAM DESCRIPITION:
# This program is  used to smimulate the 2 dimenssion Ising mdoel using
# the metropolis algorithm.
#
# For simplicity, I use python langulage to finish the  program.
#
# PROGRAMMER: caicailiushui
# DATE: 2017/12/25


from __future__ import division
import numpy as np

from numpy.random import rand    # to get the random number
import matplotlib.pyplot as plt  # to plot


# ------------------------------------------------------------------------------------------------
## 1.  Define the necessary functions used in the main program
# ------------------------------------------------------------------------------------------------

## function 1: to initial the system state
## N * N matrices
## matrix element {-1,1}
def initialstate(N):
#	state = 2 * np.random.randint(2, size = (N,N)) - 1
	state = np.ones((N,N))
	return state


## function 2: evolve to the equilibrium state
## Monte Carlo move using the metropolis algorithm
def mcmove(config, beta):
   
   for row in range(N):
       for col in range(N):
               row_val = row #np.random.randint(0, N)
               col_val = col #np.random.randint(0, N)
               posi =  config[row_val, col_val]
               nearspin = config[(row_val+1)%N,col_val] + config[row_val,(col_val+1)%N] + config[(row_val-1)%N,col_val] + config[row_val,(col_val-1)%N]
               diffEnergy = 2*posi*nearspin
               if diffEnergy &lt; 0:
                   posi *= -1
               elif rand() &lt; np.exp(-diffEnergy*beta):
                   posi *= -1
               config[row_val, col_val] = posi
   return config



## function 3: to calculate the energy of a given configuration

def calcEnergy(config):
    energy = 0.0
    dim = len(config)
    for row in range(dim):
    	for col in range(dim):
    		posi = config[row, col]
    		# near total spin
    		nearspin = config[(row + 1) % N, col] + config[(row - 1) % N, col] + config[row, (col + 1) % N] + config[row, (col - 1) % N]
    		energy += -posi*nearspin

    return energy/4.0


## function 4 : to calculate the total spin of a given configuration or  the magnetization
def calcMag(config):
	mag = np.sum(config)

	return mag

# ------------------------------------------------------------------------------------------------
## 2. Main code
#------------------------------------------------------------------------------------------------

# define the dimension of spin system

N       = 2 #16  # size of the spin lattice, N*N

# simulate parameters

Nt      = 1000 # number of temperature points

eqSteps = 1000 # uplimit of  the steps to equilibrium
mcSteps = 2000 # uplimit of  the total calculation times


Tc    = 2.269
T_arr = np.linspace(0.01, 6, Nt);   
Nt    = np.size(T_arr) # number of temperature points
# Initalization

Energy          = np.zeros(Nt)
Magnetization   = np.zeros(Nt)
SpecificHeat    = np.zeros(Nt)
Susceptibility  = np.zeros(Nt)



# Assited qualites

N1, N2  = 1.0/(mcSteps*N*N), 1.0/(mcSteps*mcSteps*N*N)

# Monto Carlo simulation

for m in range(len(T_arr)):
	E1 = M1 = E2 = M2 = 0
    
	config = initialstate(N)
    
	invT   = 1.0 / T_arr[m]
	invT2  = invT * invT

#	for i in range(eqSteps):  # equilibrate
#		mcmove(config, invT)  # Monto Carlo moves

	for i in range(mcSteps):
		mcmove(config, invT)
        
		Ene_tem = calcEnergy(config)
		Mag     = calcMag(config)

		E1 += Ene_tem
		M1 += Mag
		M2 += Mag*Mag
		E2 += Ene_tem*Ene_tem

		Energy[m]         = N1 * E1
		Magnetization[m]  = N1 * M1
		SpecificHeat[m]   = (N1*E2 - N2*E1*E1) * invT2
		Susceptibility[m] = (N1*M2 - N2*M1*M1)*invT


# Plot to show the final result
fig = plt.figure(figsize=(18,10));

sp  = fig.add_subplot(2, 2, 1);
plt.plot(T_arr, Energy, 'o', color=&quot;#6699A1&quot;);
plt.xlabel(&quot;Temperature (${T}$)&quot;, fontsize = 20);
plt.ylabel(&quot;Energy(${E}$)&quot;, fontsize = 20);


sp  = fig.add_subplot(2, 2, 2);
plt.plot(T_arr, abs(Magnetization), 'o', color=&quot;#F75C2F&quot;);
plt.xlabel(&quot;Temperature (${T}$)&quot;, fontsize=20);
plt.ylabel(&quot;Magnetization(${M}$) &quot;, fontsize=20);


sp  = fig.add_subplot(2, 2, 3);
plt.plot(T_arr, SpecificHeat, 'o', color=&quot;#6699A1&quot;);
plt.xlabel(&quot;Temperature (${T}$)&quot;, fontsize=20);
plt.ylabel(&quot;Specific Heat(${C_v}$) &quot;, fontsize=20);


sp  = fig.add_subplot(2, 2, 4);
plt.plot(T_arr, Susceptibility, 'o', color=&quot;#F75C2F&quot;);
plt.xlabel(&quot;Temperature (${T}$)&quot;, fontsize=20);
plt.ylabel(&quot;Susceptibility(${\chi}$)&quot;, fontsize=20);
</code></pre>


  <footer>
  
  <script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
  
  



<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/tex.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/python.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/lisp.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">&copy; <a href="https://qiangua.me">Qiangua</a> 2019 | <a href="https://www.instagram.com/mlyqdd/">Instagram</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

